
力扣题目50:
实现 pow(x, n) ，即计算 x 的 n 次幂函数。
``` python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        if n==0:
            return 1.0
        sign = str(bin(abs(n)))[3:]
        res = x
        for i in sign:
            res *= res
            if i=="1":
                res *= x
        return res if n>0 else 1/res
```
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        # 分治法
        if n==1:
            return x
        elif n==0:
            return 1.0
        elif n<0:
            return 1/self.myPow(x, -n)
        elif n%2==1:
            return x*self.myPow(x, n-1)
        else:
            res = self.myPow(x, n/2)
            return res*res
```

力扣题目53：
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
``` python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 动态规划
        dp = [nums[0]]
        for i in range(1,len(nums)):
            dp.append(max(nums[i], nums[i]+dp[i-1]))
        return max(dp)
```
``` python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 贪心算法
        sums, maxvalue = 0, -float('inf')
        for i in nums:
            if sums <=0:
                sums = 0
            sums += i
            maxvalue = max(maxvalue, sums)
        return maxvalue
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 分治法
        if len(nums)==1:
            return nums[0]
        else:
            left = self.maxSubArray(nums[:len(nums)//2])
            right = self.maxSubArray(nums[len(nums)//2:])
        maxl, maxr = -float('inf'), -float('inf')
        temp = 0
        for i in range(len(nums)//2-1, -1, -1):
            temp += nums[i]
            maxl = max(maxl, temp)
        temp = 0
        for i in range(len(nums)//2, len(nums)):
            temp += nums[i]
            maxr = max(maxr, temp)
        maxr = maxr if not maxr==-float('inf') else 0
        maxl = maxl if not maxl==-float('inf') else 0
        return max(left, right, maxl+maxr)
```
